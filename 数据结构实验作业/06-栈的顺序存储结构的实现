#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h> // EOF(=^Z或F6),NULL
#include<stdlib.h> // srand( ) ,rand( ),exit(n)
#include<malloc.h> // malloc( ),alloc( ),realloc( )等
#include<limits.h> // INT_MAX等
#include<string.h>
#include<ctype.h>
#include<math.h> // floor(),ceil( ),abs( )
#include<iostream> // cout,cin
#include<time.h> // clock( )
#define    TRUE          1
#define     FALSE       0 
#define     OK              1
#define     ERROR      0
#define     INFEASIBLE     -1
#define     OVERFLOW     -2 
typedef      int         Status;
typedef      int   ElemType;
typedef      int   SElemType;
#define  MAXSIZE 100     //最大长度
#define STACK_INIT_SIZE 100 // 存储空间初始分配量
typedef struct {
	SElemType* base; // base的初值为NULL
	SElemType* top; // 栈顶指针
	int      stacksize; //当前已分配的存储空间，以元素为单位
} SqStack;
//（1）初始化一个空栈；
Status InitStack(SqStack& S) {
	S.base = new SElemType[MAXSIZE];
	if (!S.base) exit(OVERFLOW);
	S.top = S.base;//top初始为base,空栈
	S.stacksize = MAXSIZE;
	return OK;
}
//（2）随机创建一个包含正整数值的栈（当输入-1时创建结束）；
Status createStack(SqStack& S) {
	int e=0;
	while (1){
	printf("输入元素(输入-1结束):");
	scanf("%d", &e);
	if (e == -1) {
		break;
	}
		if (S.top - S.base == S.stacksize) return ERROR;//栈满
		*S.top++ = e;//将元素e压入栈顶,栈顶指针加1
		/**S.Top++ = e; 虽然++优先级比* 高，但是它是后置自加，所以它是先把e存储到栈顶，然后指针上移； e = *--S.Top; 这儿
		是前置，那么和* 比较优先级，自然是--高，那么先下移指针，再把指针指向的东西赋给e；*/
		//return OK;
	};
}
//(3)将一个数x插在栈顶(x在程序运行时输入)
void Push(SqStack &s) {
	int x;
	printf("将一个数x插在栈顶:");
	scanf("%d",&x);
	//*s.top++ = x;
	*s.top = x;
	*s.top = *s.top + 1;
}
//(5)输出栈顶元素的值
void printTop(SqStack s) {
	int e = *s.top;
	printf("栈顶元素的值:%d\n", e);
}
//(4)将栈顶元素弹出，并在弹出结束后输出弹出元素的值：
void Pop(SqStack &s,SElemType &e) {
	if (s.top == s.base) printf("栈已空");
	e = *--s.top;
}
int main() {
	SqStack s;
	//（1）初始化一个空栈；
	InitStack(s);
	//（2）随机创建一个包含正整数值的栈（当输入-1时创建结束）；
	createStack(s);
	//(3)将一个数x插在栈顶(x在程序运行时输入)
	//Push(s);
	//(4)将栈顶元素弹出，并在弹出结束后输出弹出元素的值：
	/*int e=0;
	Pop(s,e);
	printf("弹出元素的值：%d\n",e);*/
	//(5)输出栈顶元素的值
	printTop(s);
};


