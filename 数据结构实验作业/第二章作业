#define _CRT_SECURE_NO_WARNINGS 1 
#include<stdio.h> // EOF(=^Z或F6),NULL
#include<stdlib.h> // srand( ) ,rand( ),exit(n)
#include<malloc.h> // malloc( ),alloc( ),realloc( )等
#include<limits.h> // INT_MAX等
#include<string.h>
#include<ctype.h>
#include<math.h> // floor(),ceil( ),abs( )
#include<iostream> // cout,cin
#include<time.h> // clock( )
#define    TRUE          1
#define     FALSE       0 
#define     OK              1
#define     ERROR      0
#define     INFEASIBLE     -1
#define     OVERFLOW     -2 
typedef      int         Status;
typedef      int   ElemType;
#define  MAXSIZE 100     //最大长度
//单链表的存储结构
typedef struct LNode {
	int data;
	struct LNode* next;
}LNode,*LinkList;
//单链表的初始化
Status InitList(LinkList &L) {
	L = new LNode;
	L->next = NULL;
	return OK;
};
//单链表的创建
void CreateList_R(LinkList& L, int n) {
	L = new LNode;
	L->next = NULL;
	LinkList r = L;
	for (int i = 0; i < n; ++i) {
		LinkList p = new LNode;
		printf("输入元素:");
		scanf("%d", &p->data);
		p->next = NULL;
		r->next = p;
		r = p;
	}
};
//查找元素
LNode* LocateElem(LinkList L, ElemType e) {
	LinkList p = L->next;
	while (p && p->data != e) {
		p = p->next;
	};
	return p;
};
//2 --- (1)
void mergeLinkList(LinkList &La,LinkList &Lb, LinkList& Lc) {
		LNode* pa = La->next;
		LNode* pb = Lb->next;
		Lc = La;
		LNode* pc = Lc;
		while (La && Lb) {
			if (pa->data < pb->data) {
				if (pa->data == pb->data) {
					pb = pb->next;
				};
				pc->next = pa;
				pc = pa;
				pa = pa->next;
			}
			else if (pa->data > pb->data) {
				pc->next = pb;
				pc = pb;
				pb = pb->next;
			}
			else {
				pc->next = pa;
				pc = pa;
				pa = pa->next;
				LNode* q = pb->next;
				delete pb;
				pb = q;
			};
		};
		pc->next = pa ? pa : pb;
		delete Lb;
};
void printLinkList(LinkList L) {
	LNode* p = L->next;
	while (p && p->data) {
		printf("%d ",p->data);
		p = p->next;
	};
	printf("\n");
}

int main() {
	LinkList La,Lb,Lc;
	int Na,Nb;
	printf("输入La表的长度");
	scanf("%d", &Na);
	CreateList_R(La, Na);
	printf("输入Lb表的长度");
	scanf("%d", &Nb);
	CreateList_R(Lb, Nb);
	mergeLinkList(La,Lb,Lc);
	printLinkList(Lc);
}
